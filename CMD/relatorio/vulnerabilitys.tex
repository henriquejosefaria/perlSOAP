\section{Vulnerabilidades Gerais}

No desenvolvimento de um software devemos sempre garantir que não divulgamos informação sobre como a nossa aplicação está construida. Durante o deenvolvimento do código deparamo-nos com dois possíveis problemas a tratar.\newline
\par O primeiro problema enuncia-se em seguida, "Como encerrar a aplicação com uma exceção passando uma mensagem de erro ao utilizador sem lhe revelar informação sobre o código da aplicação?". Para resolver este problema usamos a função \textit{die}, o problema é que esta para além da mensagem fornece informação sobre a linha onde ocorreu a exceção. Felizmente caso se adicione \textit{\\n} ao final da mensagem de erro emitida pelo die este omite a informação referente á linha. 
\par O segundo problema encontrado é referente á função \textit{open}, até ao ano 2000, a função open usava 2 parâmetros, um para a variável para a qual se lê e uma para o ficheiro a ler. O problema  acontece caso o utilizador use um ficheiro cujo nome comece, por exemplo, com o sinal \textit{>}, isto levará a que por exemplo caso seja dado como input o ficheiro \textit{>/etc/passwd} nós acabamos de apagar o ficheiro de passwords do Linux. Para resolver este problema usamos a versão do open com 3 variáveis, uma para guardar a informação a ler do ficheiro, uma para o tipo de leitura a realizar no ficheiro e uma para o nome do ficheiro. Acresce a este problema o facto de que caso o open use um pipe em vez de um ficheiro, ao falhar este devolve o pid do subprocesso na mensagem de erro, como queremos evitar divulgar qualquer informação sobre a aplicação usamos então a função \textit{die} para emitir o erro sem comprometer a nossa implementação tomando o código a seguinte forma: \textit{open(variável para leitura, modo de leitura, ficheiro a ler) or die ... }.\newline

\textit{Nota: As restantes questões de segurança foram abordadas e tratadas num modulo perl a parte chamado \textbf{verifiers.pm} criado para separar de forma legivel as subrotinas usadas para segurança das subrotinas do programa principal.}\newline 

Existem enúmeras vulnerabilidades a tratar para além das duas supramencionadas, nomeadamente:
\begin{enumerate}
\item Restrições sobre a memória
\item Neutralização do input durante a geração da página web
\item Improper Input Validation
\item Information Exposure
\item Out-of-Bounds Read
\item Neutralização de elementos especiais para comandos SQL (SQL Injection)
\item use after free
\item Integer Overflow or Wrapparound
\item XML Injection
\item OS Commands Injection
\item SQL Injection
\end{enumerate}

Destas vulnerabilidades a 1ª 4ª, 5ª, 6ª, 7ª e 8ª podem ser ignoradas visto que o \textit{Perl} trata da alocar as variáveis na memória libertando o programador da manutenção da mesma, para além. Assim vamos debruçar-nos sobre a vulnerabilidade 3, 9,10 e 11.


\subsection{Improper Input Validation}

Nesta secção falaremos um pouco dos inputs e da validação realizada sobre os mesmos. A validação de inputs de uma aplicação é fulcral para o bom funcionamento da mesma, nunca devemos acreditar que o utilizador usará a aplicação da melhor forma ou para fins nefastos.\newline
Assim os inputs a verificar são: o nome do ficheiro, o número de telefone, o pin, o OTP e o process Id.\newline

\begin{itemize}
\item Nome do ficheiro\newline
 Para realizar a verificação do nome do ficheiro foram criadas 2 listas, uma white list com os caracters aceitaveis para constituirem o nome de um ficheiro (As White Lists são especialmente proveitosas visto que é mais facil indicar o que é aceitavel do que o que não é, em contrapartida limitamos um pouco os nomes possíveis para os ficheiros fornecidos) e uma black list onde removemos algumas hipóteses aceitáveis na white list mas que não podem ser dados como input do nome do ficheiro que são as flags usadas nos inputs do programa.\newline
 Convem notar que tentativas de inserção de vários comandos através da adição de \textit{;} ou de pipes com o caracter \textit{|} não funcionam pois não pertencem á lista de caracters permitidos pela white list.

\hfill\newline
\item Número de telefone\newline
 No caso do número de telefone desenvolvemos 2 regex sendo que um funciona para números internacionais e nacionais e um que funciona apenas para números nacionais, os respetivos regex apresentam-se em seguida:\newline
\begin{itemize}
	\item \textit{/\^{}\textbackslash+[0-9]\{1,3\} [0-9]\{4,14\}\$/}
	\item \textit{/\^{}\textbackslash+351 [0-9]\{9\}\$/}
\end{itemize}

\hfill\newline
\par Como a chave móvel digital para a qual a aplicação se destina normalmente está associada a números de telemovel portugueses mantivemos o segundo regex embora tenhamos deixado em comentário o segundo regex caso pretendamos estender a aplicação a números estrangeiros. A razão de escolhermos apenas números nacionais prende-se com a esolha de implementar uma segurança com granularidade mais fina visto que o número de dígitos de telemovel varia de país para país e o indicativo também.\newline
\textit{Nota: Convem notar que, nas expressões regex, são usados por vezes 2 simbolos, o \^{} no inicio do regex e o \$ no fim. Estes simbolos indicam ao perl que o regex tem de corresponder ao inicio do input e ao final deste respetivamente, isto é, caso ambos os simbolos sejam usados o perl entende que o input a testar tem de ser totalmente formado pelo regex e, caso não seja, falha a verificação.}\newline
\hfill\newline
\item PIN\newline

\par O PIN é um conjunto de 4 digitos, assim, para o testar bastou um regex simples que garantisse isso: \textit{/\^{}[0-9]\{4\}\$/}.

\hfill\newline
\item OTP\newline
\par O OTP é verificado como endo um conjunto de 6 digitos. Mais uma vez o regex usado é bastante simples: \textit{/\^{}[0-9]\{6\}\$/}.

\end{itemize}


O principal foco da segurança na nossa aplicação foi aplicado ás strings. Os critérios usados na \textit{white List} e na \textit{Black List} não são muito restritivos, principalmente porque as strings são maleáveis e o utilizador pode dar o nome que quiser ao documento que pretende utilizar com a aplicação. Desta forma é necessário ter atenção a utilizadores mal intencionados que pretendam usar os critérios laços de filtragem de input para fins diferentes daquele para o qual a aplicação foi feita.\newline


\subsection{OS Injection}

O Perl é relativamente suscetivel a injeção de comandos do sistema operativo, isto pois permite utilizar pipelines com o caracter \textit{|} como input ou comandos seguidos separados pelo caracter \textit{;}. Para ambos os casos existe uma solução que apesar de restringir a liberdade do cliente de nomear os seus ficheiros recorrendo aos caracters \textit{|} e \textit{|} garante que estes ataques não ocorrem, o que do ponto de vista de uma maior qualidade na segurança da aplicação é o ideal.


\subsection{XML Injection}

Nesta subsecção vamos tratar de qualquer tentativa de injeção de código \textit{XML} na nossa aplicação. Para lidar com tentativas de injeção de código \textit{XML} através de um input foi criada uma subrotina chamada {xmlInjection} no modulo \textit{verifiers.pm}.\newline
Nesta subrotina para evitar eventuais tentativas de injeção de código \textit{XML} foi realizado um regex com a forma: \textit{/$<$[a-zA-Z]*($>$[\^{} ($<$\textbackslash/)]*$<$/[a-zA-Z]*|\textbackslash/)?$>$/} . Este regex permite realizar match entre elementos desta linguagem através de sintaxe conhecida detetando padrões como \textit{<qualquer coisa> ... </qualquer coisa>} ou \textit{<qualquer coisa/>}.

\subsection{SQL Injection}

Para tratar eventuais tentativas de injeção de código \textit{SQL} através das variáveis, foi definida uma subrotina chamada \textit{sqlInjection} que possui um array de palavras chave usadas na syntax \textit{SQL} que são comparadas através de um regex com os argumentos. Caso seja detetado num argumento uma palavra pertencente á syntax \textit{SQL} o programa emite uma mensagem de erro a avisar que detetou uma tentativa de SQL injection.

\section{Certificados Falsos}

Um problema quando se lida com certificados prende-se com a validação dos mesmos. De forma a contornar este problema recorreu-se ao módulo \textit{LWP::UserAgent}, este fornece uma opção por defeito de verificação automática do servidor e da sua legitimidade chamada \textit{verify\_hostname}. Assim são escolhidos protocolos seguros e é assegurado que nos ligamos a um servidor que possui um certificado válido.
